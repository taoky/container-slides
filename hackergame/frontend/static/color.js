/*
Numbers come from:
https://github.com/hsluv/hsluv-c/blob/498de4d9ce7a33933e9252fd3c87b75244215005/src/hsluv.c
I validated them against those generated by
https://github.com/colour-science/colour
Only keep 17 significant digits, because if an IEEE 754 double-precision
number is converted to a decimal string with at least 17 significant
digits, and then converted back to double-precision representation, the
final result must match the original number.

Algorithms come from:
https://peteroupc.github.io/colorgen.html
http://brucelindbloom.com/
*/

class Transform {
    constructor(...matrix) {
        return (...args) => (
            matrix.map(i => (
                i.map((j, k) => j * args[k]).reduce((a, b) => a+b, 0)
            ))
        );
    }
}

class sRGB {
    constructor(R, G, B) {
        this.R = R;
        this.G = G;
        this.B = B;
    }
    static compand(v) {
        return (v <= 0.0031308) ? (
            12.92 * v
        ) : (
            1.055 * v ** (1 / 2.4) - 0.055
        );
    }
    static inverse_compand(v) {
        return (v > 0.04045) ? (
            ((v + 0.055) / 1.055) ** 2.4
        ) : (
            v / 12.92
        );
    }
    valid() {
        return Object.values(this).every(i => i >= 0 && i <= 1);
    }
    hex() {
        return '#' + Object.values(this).map(i => (
            Math.round(i * 255).toString(16).padStart(2, '0')
        )).join('');
    }
    CIEXYZ() {
        let t = new Transform(
            [.41239079926595948, .35758433938387796, .18048078840183429],
            [.21263900587151036, .71516867876775593, .072192315360733715],
            [.019330818715591851, .11919477979462599, .95053215224966058],
        );
        return new CIEXYZ(...t(...Object.values(this).map(sRGB.inverse_compand)));
    }
    CIELUV() {
        return this.CIEXYZ().CIELUV();
    }
}

class CIEXYZ {
    constructor(X, Y, Z) {
        this.X = X;
        this.Y = Y;
        this.Z = Z;
    }
    sRGB() {
        let t = new Transform(
            [3.2409699419045213, -1.5373831775700935, -.49861076029300328],
            [-.96924363628087983, 1.8759675015077207, .041555057407175612],
            [.055630079696993608, -.20397695888897656, 1.0569715142428786],
        );
        return new sRGB(...t(...Object.values(this)).map(sRGB.compand));
    }
    CIELUV() {
        let [u_ref, v_ref] = [.19783000664283681, .46831999493879100];
        let [epsilon, kappa] = [216 / 24389, 24389 / 27];
        let L = (this.Y <= epsilon) ? (
            kappa * this.Y
        ) : (
            116 * this.Y ** (1 / 3) - 16
        );
        if (L === 0) {
            return new CIELUV(0, 0, 0);
        }
        let divider = this.X + 15 * this.Y + 3 * this.Z;
        let u = 13 * L * (4 * this.X / divider - u_ref);
        let v = 13 * L * (9 * this.Y / divider - v_ref);
        return new CIELUV(L, u, v);
    }
}

class CIELUV {
    constructor(L, u, v) {
        this.L = L;
        this.u = u;
        this.v = v;
    }
    CIEXYZ() {
        let [u_ref, v_ref] = [.19783000664283681, .46831999493879100];
        let [epsilon, kappa] = [216 / 24389, 24389 / 27];
        if (this.L === 0) {
            return new CIEXYZ(0, 0, 0);
        }
        let Y = (this.L > kappa * epsilon) ? (
            ((this.L + 16) / 116) ** 3
        ) : (
            this.L / kappa
        );
        let u_ = this.u + 13 * this.L * u_ref;
        let v_ = this.v + 13 * this.L * v_ref;
        let X = 2.25 * Y * u_ / v_;
        let Z = 39 * Y * this.L / v_ - X / 3 - 5 * Y;
        return new CIEXYZ(X, Y, Z);
    }
    sRGB() {
        return this.CIEXYZ().sRGB();
    }
}
